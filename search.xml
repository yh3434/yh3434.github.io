<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[java基础-ServiceLoader]]></title>
      <url>http://yuhang.tech/2016/12/05/2016-12-5-javabase1/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​    今天在看Vert.x源码的时候，一直没找到创建vertx对象时在哪走的实现类的构造方法。后来深入进去看到一些ServiceLoader的东西，查阅资料才知道，这是一种类似Spring依赖注入的类的初始化方式，在很多知名框架都用到，对于阅读源码还是很有帮助作用的。比如:Hadoop。</p>
<h2 id="接口代码"><a href="#接口代码" class="headerlink" title="接口代码"></a>接口代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> myInterface.ServiceLoader;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by yuhang on 2016/12/5.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="实现类代码"><a href="#实现类代码" class="headerlink" title="实现类代码"></a>实现类代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> myInterface.ServiceLoader.impl;</div><div class="line"></div><div class="line"><span class="keyword">import</span> myInterface.ServiceLoader.MyInterface;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by yuhang on 2016/12/5.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImpl_1</span> <span class="keyword">implements</span> <span class="title">MyInterface</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"MyImpl_2.handle()"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再照着上面写一个MyImpl_2，同样是实现MyInterface接口。</p>
<h2 id="测试类代码"><a href="#测试类代码" class="headerlink" title="测试类代码"></a>测试类代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> myInterface.ServiceLoader.MyInterface;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.ServiceLoader;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by yuhang on 2016/12/5.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceLoderTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@param</span> args</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">//need to define related class full name in /META-INF/services/....</span></div><div class="line">        ServiceLoader&lt;MyInterface&gt; serviceLoader = ServiceLoader</div><div class="line">                .load(MyInterface.class);</div><div class="line">        <span class="keyword">for</span> (MyInterface service : serviceLoader) &#123;</div><div class="line">            service.handle();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">myInterface.ServiceLoader.impl.MyImpl_1</div><div class="line">myInterface.ServiceLoader.impl.MyImpl_2</div></pre></td></tr></table></figure>
<h2 id="结构层次图"><a href="#结构层次图" class="headerlink" title="结构层次图"></a>结构层次图</h2><p><img src="images/myInterface.png" alt=""></p>
<p><img src="images/meta_inf.png" alt=""></p>
<p>第一次截图有点丑，凑合看下。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[多线程学习—5-线程池的其他组件]]></title>
      <url>http://yuhang.tech/2016/12/05/2016-12-5-multiThread5/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​    多线程的基础功能已经总结完了，还剩几个djk为我们提供的组件来配合不同的使用场景。今天总结下使用方法，源码等有时间再深究吧。</p>
<h1 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h1><p><strong>Timer的作用</strong></p>
<ul>
<li>执行定时任务。<ul>
<li>计划时间晚于当前时间：未来执行</li>
<li>计划时间早于当前时间：立即执行</li>
<li>允许多个任务同时执行</li>
</ul>
</li>
<li>cancle<ul>
<li>timer的cancle，清除所有的定时任务</li>
<li>timeTask的cancle，清除某一个任务</li>
</ul>
</li>
</ul>
<h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><p>​    用”中式英语翻译”就是当”计数未完成时一直锁住”，即规定的线程个数达到预期的状态时触发事件，让其他线程得以继续工作。我觉得还是比较实用的，在”汇总”工作时经常用到。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> MyThread;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by yuhang on 2016/12/5.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread11</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> CountDownLatch cdl;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sleepSecond;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread11</span><span class="params">(String name, CountDownLatch cdl, <span class="keyword">int</span> sleepSecond)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(name);</div><div class="line">        <span class="keyword">this</span>.cdl = cdl;</div><div class="line">        <span class="keyword">this</span>.sleepSecond = sleepSecond;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            System.out.println(<span class="keyword">this</span>.getName() + <span class="string">"启动了 !"</span>);</div><div class="line">            <span class="keyword">long</span> time = System.currentTimeMillis();</div><div class="line">            Thread.sleep(sleepSecond * <span class="number">1000</span>);</div><div class="line">            cdl.countDown();</div><div class="line">            System.out.println(<span class="keyword">this</span>.getName() + <span class="string">"执行完了，时间为"</span> + (System.currentTimeMillis() - time) / <span class="number">1000</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DoneThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> CountDownLatch cdl;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DoneThread</span><span class="params">(String name, CountDownLatch cdl)</span> </span>&#123;</div><div class="line">            <span class="keyword">super</span>(name);</div><div class="line">            <span class="keyword">this</span>.cdl = cdl;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                System.out.println(<span class="keyword">this</span>.getName() + <span class="string">"要等待了！"</span>);</div><div class="line">                <span class="keyword">long</span> time = System.currentTimeMillis();</div><div class="line">                cdl.await();<span class="comment">//等待countDown()</span></div><div class="line">                System.out.println(<span class="keyword">this</span>.getName() + <span class="string">"等待完了, 等待时间为："</span> + (System.currentTimeMillis() - time) / <span class="number">1000</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">//改变参数来体验被唤醒的情况</span></div><div class="line">        CountDownLatch cdl = <span class="keyword">new</span> CountDownLatch(<span class="number">3</span>);</div><div class="line">        DoneThread dt0 = <span class="keyword">new</span> DoneThread(<span class="string">"DoneThread1"</span>, cdl);</div><div class="line">        DoneThread dt1 = <span class="keyword">new</span> DoneThread(<span class="string">"DoneThread2"</span>, cdl);</div><div class="line">        dt0.start();</div><div class="line">        dt1.start();</div><div class="line">        MyThread11 wt0 = <span class="keyword">new</span> MyThread11(<span class="string">"WorkThread1"</span>, cdl, <span class="number">2</span>);</div><div class="line">        MyThread11 wt1 = <span class="keyword">new</span> MyThread11(<span class="string">"WorkThread2"</span>, cdl, <span class="number">3</span>);</div><div class="line">        MyThread11 wt2 = <span class="keyword">new</span> MyThread11(<span class="string">"WorkThread3"</span>, cdl, <span class="number">4</span>);</div><div class="line">        wt0.start();</div><div class="line">        wt1.start();</div><div class="line">        wt2.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="SemaPhore"><a href="#SemaPhore" class="headerlink" title="SemaPhore"></a>SemaPhore</h1><p>​    SemaPhore有两个主要的方法：acquire和release。分别是获得和释放信号，在创建SemaPhore指定一个int型的参数，当acquire等于这个数时，后来的acquire方法会被阻塞住，直到release信号时。注意SemaPhore是可以指定公平锁的。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">package MyThread;</div><div class="line"></div><div class="line">import java.util.concurrent.Semaphore;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by yuhang on 2016/12/5.</div><div class="line"> */</div><div class="line">public class MyThread12 &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        //可以改变参数来控制允许并发的数量</div><div class="line">        final Semaphore semaphore = new Semaphore(4);</div><div class="line"></div><div class="line">        Runnable runnable = () -&gt; &#123;</div><div class="line">            try &#123;</div><div class="line">                semaphore.acquire();</div><div class="line">                System.out.println(Thread.currentThread().getName() + "获得了信号量 ！");</div><div class="line">                long time = System.currentTimeMillis();</div><div class="line">                Thread.sleep(2000);</div><div class="line">                System.out.println(Thread.currentThread().getName() + "释放了信号量,时间为" + (System.currentTimeMillis() - time) / 1000 + " 秒");</div><div class="line">            &#125; catch (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125; finally &#123;</div><div class="line">                semaphore.release();</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line"></div><div class="line">        Thread[] threads = new Thread[10];</div><div class="line">        for (int i = 0; i &lt; threads.length; i++)</div><div class="line">            threads[i] = new Thread(runnable);</div><div class="line">        for (int i = 0; i &lt; threads.length; i++) &#123;</div><div class="line">            threads[i].start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h1><p>​    再次用”用中式英语”理解下字面意思：将给定数量的成员集中在一个屏障点上，然后在统一执行后面的操作。意思即是若干个线程一起执行，当数量达到某个条件时，线程阻塞，等某个任务执行完时，再继续执行await()以后的代码。和前面的CountDownLatch有点像，但是是完全不同的，先运行下代码，再来总结不同点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> MyThread;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by yuhang on 2016/12/5.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread14</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> CyclicBarrier cb;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> sleepSecond;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrierThread</span><span class="params">(CyclicBarrier cb, <span class="keyword">int</span> sleepSecond)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.cb = cb;</div><div class="line">            <span class="keyword">this</span>.sleepSecond = sleepSecond;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                System.out.println(<span class="keyword">this</span>.getName() + <span class="string">"运行了"</span>);</div><div class="line">                Thread.sleep(sleepSecond * <span class="number">1000</span>);</div><div class="line">                System.out.println(<span class="keyword">this</span>.getName() + <span class="string">"准备等待了, 时间为"</span> + System.currentTimeMillis());</div><div class="line">                cb.await();</div><div class="line">                System.out.println(<span class="keyword">this</span>.getName() + <span class="string">"结束等待了, 时间为"</span> + System.currentTimeMillis());</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Runnable runnable = () -&gt; System.out.println(<span class="string">"CyclicBarrier的所有线程await()结束了，我运行了, 时间为"</span> + System.currentTimeMillis());</div><div class="line">        <span class="comment">//三个屏障</span></div><div class="line">        CyclicBarrier cb = <span class="keyword">new</span> CyclicBarrier(<span class="number">3</span>, runnable);</div><div class="line">        CyclicBarrierThread cbt0 = <span class="keyword">new</span> CyclicBarrierThread(cb, <span class="number">3</span>);</div><div class="line">        CyclicBarrierThread cbt1 = <span class="keyword">new</span> CyclicBarrierThread(cb, <span class="number">6</span>);</div><div class="line">        CyclicBarrierThread cbt2 = <span class="keyword">new</span> CyclicBarrierThread(cb, <span class="number">9</span>);</div><div class="line">        cbt0.start();</div><div class="line">        cbt1.start();</div><div class="line">        cbt2.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="CyclicBarrier和CountDownLatch的区别"><a href="#CyclicBarrier和CountDownLatch的区别" class="headerlink" title="CyclicBarrier和CountDownLatch的区别"></a>CyclicBarrier和CountDownLatch的区别</h1><p>根据上面两个demo其实可以理解：</p>
<ul>
<li>countDown()方法执行仅仅是给”计数器减一”，然后当前线程不阻塞，继续运行下面的代码，当”计数器为0”时，会触发多个任务；而CyclicBarrier是”计数器”运行到”屏障”前必须阻塞，知道屏障内的代码执行完，前面的线程才会继续执行，并且仅仅只唤醒了一个”屏障内的线程”。</li>
<li>CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了。</li>
</ul>
<p>理解其原理，区别自然是很简单就能说出来了。</p>
<h1 id="Future和Callable"><a href="#Future和Callable" class="headerlink" title="Future和Callable"></a>Future和Callable</h1><p>​    比较简单。跑一遍代码，使用它们的优点是，如果先执行A方法再执行B方法，但是B方法需要10S，A方法需要5S，传统方法等A执行完，再执行B，一共需要15s,造成了时间上的浪费，使用Future和Callable能够并行执行，自然不会存在这样的问题了,传统多线程也能做到，只是不好取的返回值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> MyThread;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Future;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by yuhang on 2016/12/5.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread15</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            System.out.println(<span class="string">"进入CallableThread的call()方法, 开始睡觉, 睡觉时间为"</span> + System.currentTimeMillis());</div><div class="line">            Thread.sleep(<span class="number">10000</span>);</div><div class="line">            <span class="keyword">return</span> <span class="string">"123"</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        ExecutorService es = Executors.newCachedThreadPool();</div><div class="line">        CallableThread ct = <span class="keyword">new</span> CallableThread();</div><div class="line">        Future&lt;String&gt; f = es.submit(ct);</div><div class="line">        es.shutdown();</div><div class="line"></div><div class="line">        Thread.sleep(<span class="number">5000</span>);</div><div class="line">        System.out.println(<span class="string">"主线程等待5秒, 当前时间为"</span> + System.currentTimeMillis());</div><div class="line"></div><div class="line">        String str = f.get();</div><div class="line">        System.out.println(<span class="string">"Future已拿到数据, str = "</span> + str + <span class="string">", 当前时间为"</span> + System.currentTimeMillis());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>多线程常用知识终于总结完了，其实也没那么复杂，对吧？还是那句话，坚持就是胜利！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[多线程学习—4-线程池的使用]]></title>
      <url>http://yuhang.tech/2016/12/04/2016-12-4-multiThread4/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​    写到线程池这块先回忆一段小插曲。13年12月的时候，差不多也是现在这个季节，刚实习一个月似懂非懂拿着活就干的我第一次接触到线程池，当时是做一个上报到的任务，差不多每天需要上传70万数据到一个接口。沈阳的大背景技术不是很强，工作了三四年的一些老程序员也很少接触到多线程。当时没用多线程之前差不多是</p>
<p>700000/(60*60*24*10)接近一天才能上报完，并且是程序不出错的情况下。于是乎白哥（我的第一个项目经理,这里要感谢白哥在我工作之初的时候谆谆教导！和第一份工作远在东北的同事们！）想到了用多线程来处理，也许是没时间研究底层，出来的效果也不尽人意，总是会丢数据，虽然时间加快到两个小时以内，不知天高地厚的我，当然也是不懂把失败策略，改了下在类似以下的代码中把原来的代码（原来代码不记得了）改为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//线程池对拒绝任务的处理策略</span></div><div class="line">  <span class="keyword">final</span> RejectedExecutionHandler Errorhandler = <span class="keyword">new</span> RejectedExecutionHandler() &#123;</div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">( Runnable r, ThreadPoolExecutor executor )</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (!executor.isShutdown()) &#123;</div><div class="line">           r.run();</div><div class="line">        &#125;</div><div class="line">        &#125;</div><div class="line">  &#125;;</div></pre></td></tr></table></figure>
<p> 其实就是把if语句内替换成r.run()这一句，居然奇迹般的不丢数据了，当时我第一次感到程序和多线程的魅力，后来浑浑噩噩的这么久整整三年竟然还是似懂非懂，说来惭愧！这几天继续学习多线程，刚好看到线程池这边，回忆起往事真是感慨颇多，多年前定的计划能完成的真是少之又少，希望以后能分而划之的坚持下去！</p>
<h1 id="线程池的作用"><a href="#线程池的作用" class="headerlink" title="线程池的作用"></a>线程池的作用</h1><p><strong>线程池的作用</strong></p>
<p>线程池的作用就2个：</p>
<ul>
<li>减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务</li>
<li>可以根据系统的承受能力，调整线程池中工作线程的数据，防止因为消耗过多的内存导致服务器崩溃</li>
</ul>
<p>​       使用线程池，要根据系统的环境情况，手动或自动设置线程数目。少了系统运行效率不高，多了系统拥挤、占用内存多。用线程池控制数量，其他线程排队等候。一个任务执行完毕，再从队列中取最前面的任务开始执行。若任务中没有等待任务，线程池这一资源处于等待。当一个新任务需要运行，如果线程池中有等待的工作线程，就可以开始运行了，否则进入等待队列。</p>
<p>​    可以适当的修改文末代码中的参数来体验一下速度或者在excute里加上sleep方法，感受下失败策略（即丢数据的情况），减小线程池数量大小可以加快速度，因为减少了线程池创建的时间，但是相应的降低了系统的处理能力。</p>
<h1 id="参数总结"><a href="#参数总结" class="headerlink" title="参数总结"></a>参数总结</h1><ul>
<li><p>池中线程数小于corePoolSize，新任务都不排队而是直接添加新线程</p>
</li>
<li><p>池中线程数大于等于corePoolSize，workQueue未满，首选将新任务假如workQueue而不是添加新线程</p>
</li>
<li><p>池中线程数大于等于corePoolSize，workQueue已满，但是线程数小于maximumPoolSize，添加新的线程来处理被添加的任务</p>
</li>
<li><p>池中线程数大于大于corePoolSize，workQueue已满，并且线程数大于等于maximumPoolSize，新任务被拒绝，使用handler处理被拒绝的任务</p>
<p>上面的四个总结是前辈所写，由于这里主要是记录本人学习过程，就不添加链接了。</p>
</li>
</ul>
<h1 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a><strong>Executors</strong></h1><p>JDK推荐的三个Executors：</p>
<ul>
<li><p>单线程线程池</p>
<p>那么线程池中运行的线程数肯定是1。workQueue选择了无界的LinkedBlockingQueue，那么不管来多少任务都排队，前面一个任务执行完毕，再执行队列中的线程。从这个角度讲，第二个参数maximumPoolSize是没有意义的，因为maximumPoolSize描述的是排队的任务多过workQueue的容量，线程池中最多只能容纳maximumPoolSize个任务，现在workQueue是无界的，也就是说排队的任务永远不会多过workQueue的容量，那maximum其实设置多少都无所谓了。</p>
</li>
<li><p>newFixedThreadPool(int nThreads)   <strong>固定大小线程池</strong></p>
<p>固定大小的线程池和单线程的线程池异曲同工，无非是让线程池中能运行的线程编程了手动指定的nThreads罢了。同样，由于是选择了LinkedBlockingQueue，因此其实第二个参数maximumPoolSize同样也是无意义的</p>
</li>
<li><p>newCachedThreadPool()   <strong>无界线程池</strong></p>
<p>无界线程池，意思是不管多少任务提交进来，都直接运行。无界线程池采用了SynchronousQueue，采用这个线程池就没有workQueue容量一说了，只要添加进去的线程就会被拿去用。既然是无界线程池，那线程数肯定没上限，所以以maximumPoolSize为主了，设置为一个近似的无限大Integer.MAX_VALUE。 另外注意一下，单线程线程池和固定大小线程池线程都不会进行自动回收的，也即是说保证提交进来的任务最终都会被处理，但至于什么时候处理，就要看处理能力了。但是无界线程池是设置了回收时间的，由于corePoolSize为0，所以只要60秒没有被用到的线程都会被直接移除。</p>
<p>​</p>
</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> MyThread;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.Vector;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.*;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by yuhang on 2016/12/4.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread9</span> </span>&#123;</div><div class="line">    <span class="comment">//维护线程池最小的数量</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = <span class="number">100</span>;<span class="comment">//改完1速度更快了，因为开启线程数量变少，但是相应的系统处理能力就变弱了</span></div><div class="line">    <span class="comment">//线程池维护的最大数量</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">100</span>;</div><div class="line">    <span class="comment">//线程池维护线程所允许的空余时间</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> KEEP_ALIVE_TIME = <span class="number">0</span>;</div><div class="line">    <span class="comment">//缓冲队列的大小</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WORK_QUEUE_SIZE = <span class="number">2000</span>;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Integer&gt; l = <span class="keyword">new</span> Vector&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="comment">//线程池对拒绝任务的处理策略</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> RejectedExecutionHandler Errorhandler = <span class="keyword">new</span> RejectedExecutionHandler() &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (!executor.isShutdown()) &#123;</div><div class="line">                <span class="comment">//r.run();</span></div><div class="line">                System.out.println(<span class="string">"注释掉 r.run() WORK_QUEUE_SIZE 为100时，会出现丢数据的情况!"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="comment">//JDK提倡用Executors三个工厂方法</span></div><div class="line">    <span class="comment">//单线程线程池</span></div><div class="line"><span class="comment">//    public static ExecutorService newSingleThreadExecutor() &#123;</span></div><div class="line"><span class="comment">//        return new FinalizableDelegatedExecutorService</span></div><div class="line"><span class="comment">//                (new ThreadPoolExecutor(1, 1,</span></div><div class="line"><span class="comment">//                        0L, TimeUnit.MILLISECONDS,</span></div><div class="line"><span class="comment">//                        new LinkedBlockingQueue&lt;&gt;()));</span></div><div class="line"><span class="comment">//    &#125;</span></div><div class="line"></div><div class="line">    <span class="comment">//无界限</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(corePoolSize, Integer.MAX_VALUE,</div><div class="line">                <span class="number">60L</span>, TimeUnit.SECONDS,</div><div class="line">                <span class="keyword">new</span> SynchronousQueue&lt;&gt;());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//固定大小线程池</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</div><div class="line">                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</div><div class="line">                <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ThreadPoolExecutor tp =</div><div class="line">            <span class="keyword">new</span> ThreadPoolExecutor(CORE_POOL_SIZE, MAX_POOL_SIZE, KEEP_ALIVE_TIME, TimeUnit.SECONDS,</div><div class="line">                    <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(WORK_QUEUE_SIZE), Errorhandler);</div><div class="line"><span class="comment">//            (ThreadPoolExecutor) MyThread9.newFixedThreadPool(1);</span></div><div class="line"><span class="comment">//            (ThreadPoolExecutor) MyThread9.newCachedThreadPool(5);</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2000</span>; i++) &#123;</div><div class="line">            tp.execute(</div><div class="line">                    <span class="keyword">new</span> Runnable() &#123;</div><div class="line">                        <span class="meta">@Override</span></div><div class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                            <span class="keyword">try</span> &#123;</div><div class="line">                                Thread.sleep(<span class="number">10</span>);</div><div class="line">                            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                                e.printStackTrace();</div><div class="line">                            &#125;</div><div class="line">                            l.add(<span class="number">1</span>);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">            );</div><div class="line">            System.out.println(i);</div><div class="line">        &#125;</div><div class="line">        tp.shutdown();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            tp.awaitTermination(<span class="number">1</span>, TimeUnit.DAYS);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        System.out.println(System.currentTimeMillis() - startTime);</div><div class="line">        System.out.println(l.size());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[多线程学习—3-ThreadLocal的使用]]></title>
      <url>http://yuhang.tech/2016/12/02/2016-12-2-multiThread3/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​    ThreadLocal使用比较简单，重点是要理解其源码，佩服写源码的大神，为了解决散列表的冲突而引入的神奇的hash code: <strong>0x61c88647</strong>设计太巧妙了，数学白痴就不妄言分析了直接享用大神的成果吧，反正就是为了散列均匀。直接上使用代码。</p>
<ul>
<li><strong>ThreadLocal不是集合</strong>，它不存储任何内容，真正存储数据的集合在Thread中。<strong>ThreadLocal只是一个工具，一个往各个线程的ThreadLocal.ThreadLocalMap中table的某一位置set一个值的工具而已</strong></li>
</ul>
<ul>
<li>每个线程都有一个自己的ThreadLocal.ThreadLocalMap对象</li>
<li>每一个ThreadLocal对象都有一个循环计数器</li>
<li>ThreadLocal.get()取值，就是根据当前的线程，获取线程中自己的ThreadLocal.ThreadLocalMap，然后在这个Map中根据第二点中循环计数器取得一个特定value值</li>
</ul>
<h1 id="与同步对比"><a href="#与同步对比" class="headerlink" title="与同步对比"></a>与同步对比</h1><ul>
<li>同步与ThreadLocal是解决多线程中数据访问问题的两种思路，<strong>前者是数据共享的思路</strong>，<strong>后者是数据隔离的思路</strong></li>
<li>同步是一种以时间换空间的思想，ThreadLocal是一种空间换时间的思想</li>
</ul>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> MyThread;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by yuhang on 2016/12/2.</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread4</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; seqNum</div><div class="line">            = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;() &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNextNum</span><span class="params">()</span> </span>&#123;</div><div class="line">        seqNum.set(seqNum.get() + <span class="number">1</span>);</div><div class="line">        <span class="keyword">return</span> seqNum.get();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        MyThread4 sn = <span class="keyword">new</span> MyThread4();</div><div class="line">        TestClient t1 = <span class="keyword">new</span> TestClient(sn);</div><div class="line">        TestClient t2 = <span class="keyword">new</span> TestClient(sn);</div><div class="line">        TestClient t3 = <span class="keyword">new</span> TestClient(sn);</div><div class="line">        t1.start();</div><div class="line">        t2.start();</div><div class="line">        t3.start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClient</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> MyThread4 sn;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TestClient</span><span class="params">(MyThread4 sn)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.sn = sn;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</div><div class="line">                System.out.println(<span class="string">"thread["</span> + Thread.currentThread().getName()</div><div class="line">                        + <span class="string">"]sn["</span> + sn.getNextNum() + <span class="string">"]"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[多线程学习—2-volatile的使用]]></title>
      <url>http://yuhang.tech/2016/12/01/multiThread2/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​        今天继续学习多线程，本来volatile关键字应该很好理解，不需要单独写博客记录。但是今天碰到些我暂时不能解释的问题，固贴出来交流一下。</p>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>​        根据JMM，Java中有一块主内存，不同的线程有自己的工作内存，同一个变量值在主内存中有一份，如果线程用到了这个变量的话，自己的工作内存中有一份一模一样的拷贝。每次进入线程从主内存中拿到变量值，每次执行完线程将变量从工作内存同步回主内存中。</p>
<p>​        被volatile修饰的变量，保证了每次读取到的都是最新的那个值。线程安全围绕的是<strong>可见性</strong>和<strong>原子性</strong>这两个特性展开的，<strong>volatile解决的是变量在多个线程之间的可见性，但是无法保证原子性</strong>。如下面代码所示，进入while循环时，如果不加volatile关键字，注释掉System.out.println(“running”);这行代码，程序是跳不出循环的，但是加上volatile关键字就能跳出了，这证明了volatile解决的是变量在多个线程之间的可见性。可是奇怪的是我将System.out.println(“running”);取消注释，即使不加上volatile也能跳出循环，还望明白的交流解释。我的测试环境是jdk 1.8</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> MyThread;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by yuhang on 2016/12/1.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread3</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    <span class="comment">//    volatile</span></div><div class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"a: "</span> + a);</div><div class="line">        <span class="keyword">while</span> (a == <span class="number">1</span>) &#123;</div><div class="line">            <span class="comment">//  System.out.println("running");</span></div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"while loop end"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        MyThread3 myThread3 = <span class="keyword">new</span> MyThread3();</div><div class="line">        myThread3.start();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(<span class="number">1000</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        myThread3.a = <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[多线程学习—1-wait(),notify(),notifyAll()]]></title>
      <url>http://yuhang.tech/2016/11/30/multiThread1/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​        最近准备把多线程的知识重新过一遍，决定从基础写起。这篇主要讲的是多线程的wait(),notify(),notifyAll()方法。</p>
<p>这三个方法都属于类方法，Object类都会有这三个方法，wait()是暂时让出<strong><em>锁</em></strong>给其他线程，而当前线程会一直阻塞直到等到notify(All)通知或者中断，而notify()和notifyAll()则是通知持有该锁的对象”<strong>等待</strong>获取该对象的对象锁”，因此必须要写在同步代码块内，至于为什么notify()和notifyAll()是通知”等待”，下面会详细解释。</p>
<h2 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h2><p>​        wait()的作用是使当前执行代码的线程进行等待，将当前线程置入”预执行队列”中，并且wait()所在的代码处停止执行，直到接到通知或被中断。<strong>在调用wait()之前，线程必须获得该对象的锁，因此只能在同步方法/同步代码块中调用wait()方法</strong>。</p>
<h2 id="notify-All"><a href="#notify-All" class="headerlink" title="notify(All)"></a>notify(All)</h2><p>​        notify()的作用是，如果有多个线程等待，那么线程规划器随机挑选出一个wait的线程，对其发出通知notify()，并使它等待获取该对象的对象锁。注意”等待获取该对象的对象锁”，这意味着，即使收到了通知，wait的线程也不会马上获取对象锁，必须等待notify()方法的线程释放锁才可以。<strong>和wait()一样，notify()也要在同步方法/同步代码块中调用</strong>。</p>
<p>总结起来就是，<strong>wait()使线程停止运行，notify()使停止运行的线程继续运行</strong>。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>​        上面关于wait和notify的总结是前辈写的，下面给出我自己的示例。请大家根据注释，适当的去掉注释看看结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> MyThread;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by yuhang on 2016/11/30.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    Object lock = <span class="keyword">new</span> Object();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread1</span><span class="params">(Object lock)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Constructor method-&gt;&gt;CurrentThreadName:  "</span> + Thread.currentThread().getName());</div><div class="line">        System.out.println(<span class="string">"Constructor method-&gt;&gt;this.threadName:   "</span> + <span class="keyword">this</span>.getName());</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"**********************************************"</span>);</div><div class="line">        <span class="keyword">this</span>.lock = lock;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.lock) &#123;</div><div class="line">            System.out.println(<span class="string">"Run method-&gt;&gt;CurrentThreadName:   "</span> + Thread.currentThread().getName());</div><div class="line">            System.out.println(<span class="string">"Run method-&gt;&gt;this.threadName:     "</span> + <span class="keyword">this</span>.getName());</div><div class="line"></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                System.out.println(<span class="string">"MyThread1:"</span> + Thread.currentThread().getName() + <span class="string">" get the lock,and i will wait for some notify!"</span>);</div><div class="line">                <span class="keyword">long</span> statrTime = System.currentTimeMillis();</div><div class="line">                <span class="comment">//wait是让使用wait方法的对象等待，暂时先把对象锁给让出来，给其它持有该锁的对象用，其它对象用完后再告知（notify）等待的那个对象可以继续执行了</span></div><div class="line">                <span class="keyword">this</span>.lock.wait();</div><div class="line">                System.out.println(<span class="string">"MyThread1"</span> + Thread.currentThread().getName() + <span class="string">" wait end! lock time : "</span> + (System.currentTimeMillis() - statrTime) / <span class="number">1000</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                System.out.println(<span class="string">"wait be interrupted by interrupt method just now!"</span>);</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Object lock = <span class="keyword">new</span> Object();</div><div class="line">        MyThread1 myThread1 = <span class="keyword">new</span> MyThread1(lock);</div><div class="line">        MyThread1 myThread2 = <span class="keyword">new</span> MyThread1(lock);</div><div class="line">        myThread1.start();</div><div class="line">        myThread2.start();</div><div class="line">        <span class="comment">//wait和notify必须要写在同步代码块内部 否则会报java.lang.IllegalMonitorStateException异常</span></div><div class="line">        <span class="keyword">synchronized</span> (lock) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Thread.sleep(<span class="number">3000</span>);</div><div class="line">                lock.notifyAll();</div><div class="line">                <span class="comment">//lock.wait();</span></div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> MyThread;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by yuhang on 2016/11/30.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">    Object lock = <span class="keyword">new</span> Object();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread2</span><span class="params">(Object lock)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.lock = lock;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span> (lock) &#123;</div><div class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"will notify!"</span>);</div><div class="line">            <span class="comment">//notify不会马上释放锁，会等到当前同步代码块执行完，才会释放锁</span></div><div class="line">            lock.notify();</div><div class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" notified ,but didn't release!"</span>);</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Thread.sleep(<span class="number">1000</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" after sleep,will release the lock!"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Object lock = <span class="keyword">new</span> Object();</div><div class="line">        MyThread1 myThread1 = <span class="keyword">new</span> MyThread1(lock);</div><div class="line">        myThread1.start();</div><div class="line">        <span class="comment">//测试Notify不释放锁</span></div><div class="line">        MyThread2 myThread2 = <span class="keyword">new</span> MyThread2(lock);</div><div class="line">        <span class="comment">//myThread2.start();</span></div><div class="line"></div><div class="line">        <span class="comment">//测试interrupt方法</span></div><div class="line"><span class="comment">//        try &#123;</span></div><div class="line"><span class="comment">//            Thread.sleep(10000);</span></div><div class="line"><span class="comment">//        &#125; catch (InterruptedException e) &#123;</span></div><div class="line"><span class="comment">//            e.printStackTrace();</span></div><div class="line"><span class="comment">//        &#125;</span></div><div class="line"><span class="comment">//        System.out.println(myThread1.getName() + "will execute interrupt method!");</span></div><div class="line"><span class="comment">//        myThread1.interrupt();</span></div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//join方法会释放锁,但是不加时间会一直阻塞当前执行的线程直到myThead1的run方法执行完成</span></div><div class="line">            myThread1.join();<span class="comment">//.join(1000);</span></div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果没有Join方法myThead2线程是不会启动的</span></div><div class="line">        myThread2.start();</div><div class="line">        System.out.println(<span class="string">"i will print after myThead1 complete!"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[测试下分类和标签]]></title>
      <url>http://yuhang.tech/2016/10/16/second/</url>
      <content type="html"><![CDATA[<h1 id="测试分类和标签"><a href="#测试分类和标签" class="headerlink" title="测试分类和标签"></a>测试分类和标签</h1><p>测试分类和标签</p>
<h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><pre><code>public static void main(String args[]){
    System.out.printl(&quot;Hello World!&quot;);
}
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[我的博客上线啦]]></title>
      <url>http://yuhang.tech/2016/10/16/first/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>  我的博客上线啦！</p>
<h1 id="中间"><a href="#中间" class="headerlink" title="中间"></a>中间</h1><p>  告别了两年没变的编程方式，换了工作，换了城市，换了mac,换了intellJ ieda,换了maven，换了git，告别了tomcat。<br>  准备好好写博客啦！朝着全栈工程师努力！</p>
<h1 id="后面"><a href="#后面" class="headerlink" title="后面"></a>后面</h1><p>  准备把两年前实习时写的一整套的微信公众平台重新开发，并且开源出来，会用到新的vertx.x技术，准备把servlet+mysql去掉，换成vert.x和mongodb+redis，欢迎关注。    </p>
]]></content>
    </entry>
    
  
  
</search>
